
Client has client details and policy number of insurance policy.
Policy has only policy details.

Claim has policy clientid and policy number.


Sure, let's break down the concepts of `Insurance`, `Claim`, and `Client`, and then explain how they work together in the context of the provided Spring Boot application.

### Insurance Concept

**Insurance** is a contract represented by a policy in which an individual or entity receives financial protection or reimbursement against losses from an insurance company. The company pools clients' risks to make payments more affordable for the insured.

- **Insurance Policy**: A document detailing the terms and conditions of a contract of insurance. The policy will include the type of coverage, the amount of coverage, premiums, and the duration of the coverage.

### Claim Concept

A **Claim** is a formal request by a policyholder to an insurance company for coverage or compensation for a covered loss or policy event.

- **Claim Process**: When an incident occurs, the insured submits a claim to the insurance company. The company will then review the claim, and if it falls under the policy's coverage, they will approve the claim and reimburse the insured.

### Client Concept

A **Client** is an individual or entity who purchases an insurance policy from an insurance company.

- **Client Relationship**: The client pays premiums to the insurance company in exchange for financial protection or reimbursement for specified losses.

### How It Works Together

1. **Client Purchase**: The client purchases an insurance policy from the insurance company.
2. **Premium Payment**: The client pays a premium to the insurance company at regular intervals.
3. **Incident Occurrence**: An event occurs that is covered under the insurance policy (e.g., a car accident, medical emergency, property damage).
4. **Claim Submission**: The client submits a claim to the insurance company.
5. **Claim Review**: The insurance company reviews the claim to determine if it is valid and covered under the policy.
6. **Claim Approval/Denial**: If the claim is valid, the insurance company approves it and reimburses the client. If not, the claim is denied.

### How the Provided Code Works

#### Entities

1. **Client Entity**:
   - Represents a person or entity that holds an insurance policy.
   - Contains personal details such as name, date of birth, address, contact number, and references to `InsurancePolicy` and a list of `Claim`s.
   - Uses JPA annotations for database mappings.

2. **InsurancePolicy Entity**:
   - Represents the insurance policy held by a client.
   - Contains details such as policy number, type, coverage amount, premium, start date, and end date.
   - Has a one-to-many relationship with `Client`.

3. **Claim Entity**:
   - Represents a claim made by a client.
   - Contains details such as claim number, status, amount, and a reference to the `Client`.

#### DTO (Data Transfer Object)

- **ClientResponseDTO**: A DTO used to encapsulate `Client`, `InsurancePolicy`, and `Claim` details in a single response object.

#### Service

- **ClientService**: Provides methods to save and retrieve client details from the repository. The `getClientById` method converts a `Client` entity to a `ClientResponseDTO`.

#### Controller

- **ClientController**: Handles HTTP requests for `Client` operations.
  - `createClient`: Accepts a POST request to create a new client.
  - `updateClient`: Accepts a PUT request to update an existing client's details.
  - `getClientById`: Accepts a GET request to retrieve a client's details along with their insurance policy and claims.

### Example Scenario

1. **Create a Client**: A POST request to `/api/clients` with client details.
2. **Update a Client**: A PUT request to `/api/clients/{clientId}` to update client information, excluding the insurance policy ID.
3. **Retrieve Client Details**: A GET request to `/api/clients/{clientId}` returns the client's information, their insurance policy, and associated claims.

### Example Output

When you request client details, the system will return:

```json
{
    "clientId": 1,
    "clientName": "John Doe",
    "clientDateOfBirth": "1980-01-01",
    "clientAddress": "123 Main St",
    "clientContactNumber": 1234567890,
    "insurancePolicy": {
        "insurancePolicyId": 1,
        "insurancePolicyNumber": "POL123456",
        "insurancePolicyType": "Health",
        "insurancePolicyCoverageAmount": 1000000,
        "insurancePolicyPremium": "5000",
        "insurancePolicyStartDate": "2023-01-01",
        "insurancePolicyEndDate": "2024-01-01"
    },
    "claims": [
        {
            "claimId": 1,
            "claimNumber": "CLM123456",
            "claimStatus": "Approved",
            "claimAmount": 5000
        },
        {
            "claimId": 2,
            "claimNumber": "CLM654321",
            "claimStatus": "Pending",
            "claimAmount": 2000
        }
    ]
}
```

This JSON structure provides a comprehensive view of a client, their insurance policy, and their claims, allowing for a complete understanding of their interactions with the insurance system.












REACT JS - TUTORIAL 
====================

React, the popular JavaScript library, offers several exciting reasons for developers to learn it.

First, React is flexible – once you learn its concepts, you can use it across various platforms to build quality user interfaces. 
Unlike a framework, React’s library approach allows it to evolve into a remarkable tool.

Second, React has a great developer experience, making it easier to understand and write code. 

Third, it benefits from Facebook’s support and resources, ensuring regular bug fixes, enhancements, and documentation updates. 
Additionally, React’s broader community support, excellent performance, and ease of testing make it an ideal choice for web development.

Features of React
=================
1. JSX (JavaScript Syntax Extension):
-------------------------------------
JSX combines HTML and JavaScript, allowing you to embed JavaScript objects within HTML elements.
It enhances code readability and simplifies UI development.
Example:

const name = "GeekforGeeks";
const ele = <h1>Welcome to {name}</h1>;

2. Virtual DOM (Document Object Model):
-------------------------------------
React uses a virtual DOM, which is an exact copy of the real DOM.
When there are modifications in the web application, React updates the virtual DOM first and then computes the differences between the real DOM and the virtual DOM.
This approach minimizes unnecessary re-rendering and improves performance.

3. One-way Data Binding:
--------------------------
React follows one-way data binding, where data flows from parent components to child components.
Child components cannot directly return data to their parent components, but they can communicate with parents to modify states based on provided inputs.

4. Performance:
-------------------------------------
React’s virtual DOM and component-based architecture contribute to better performance.
Separate components allow efficient rendering and faster execution.

5. Extension:
-------------------------------------
React has a rich ecosystem and supports various extensions.
Explore tools like Flux, Redux, and React Native for mobile app development and server-side rendering.

6. Conditional Statements in JSX:
-------------------------------------
JSX allows writing conditional statements directly.
Display data in the browser based on provided conditions.
Example:

const age = 12;
if (age >= 10) {
  return <p>Greater than {age}</p>;
} else {
  return <p>{age}</p>;
}


7. Components:
-------------------------------------
React divides web pages into reusable and immutable components.
Component-based development simplifies code organization and maintenance.

Core React Concepts:
here are some essential concepts to learn:

Props: Components can receive data from parent components through props, enabling you to pass information and customize component behavior.

State: Components can manage their internal state using the useState hook. This state dictates the component’s appearance and behavior, and updates trigger re-renders.

Lifecycle Methods: React provides lifecycle methods like componentDidMount and componentDidUpdate that allow you to perform actions at specific stages of a component’s lifecycle.

Conditional Rendering: Control what gets displayed on the screen based on certain conditions using conditional statements within JSX.

React Advantages
----------------
Composable: We can divide these codes and put them in custom components. Then we can utilize those components and integrate them into one place.

Declarative: In ReactJS, the DOM is declarative. We can make interactive UIs by changing the state of the component and ReactJS takes care of updating the DOM according to it.

SEO Friendly: ReactJS affects the SEO by giving you a SPA (Single Page Application) which requires Javascript to show the content on the page which can be rendered and indexed.

Community: ReactJS has a huge community because of its demand each company wants to work with ReactJS. Companies like Meta, Netflix, etc built on ReactJS.

Easy to learn: HTML-like syntax of JSX makes you comfortable with the codes of React, it only requires a basic knowledge of HTML, CSS, and JS fundamentals to start working with it.

Debugging is Easy: The debugging of ReactJS is unidirectional which means while designing any app using ReactJS the child components are nested within parent components. So, the data flow is in a single direction it gets more easier to debug errors.



Commands:
=========
npx create-react-app sample-application		- 	Creates a new React application with a standard setup.
cd sample	-	application - open newly created react application
npm start	-	Starts the development server and opens the app in a browser.
npm run build 	-	Creates an optimized production build of the app.
npm test	-	Runs the test suite using Jest.
npm run eject	-	Exposes the configuration files for customization.
npm install package-name	-	Installs a package and adds it to package.json.
npm install -g package-name	-	Installs a package globally on your system.
npm uninstall package-name	-	Removes a package from the project.


Component Types 
===============
		1. Stateless Functional Component 
		---------------------------------

		function Welcome(props){

		return <h1>Hello, {prop.name} </h1>;

		}

		2. Stateful Class Component 
		----------------------------
		Class extending Component class

		Render Method returning HTML

		class Welcome extends React.Component {

		render(){

		return <h1>Hello, {prop.name} </h1>;

		}

		}


Functional VS Class Components 
===============================
Functional 													Class
------------											-------------
1. Simple Functions 									More feature rich
2. Use Functions as much as possible 					Maintain their own private data-state
3. Absence of `this` keyword.							Complex UI logic
4. Solution Without using state.						Provide Lifecycle
5. Mainly responsible for UI.							Stateful/Smart/Container
6. Stateless/Dumb/Presentational



JSX (JAVASCRIPT EXTENSION)
==========================
JavaScript XML (JSX) - Extension to the JavaScript Language Syntax.
Write XML like code for elements and components.
JSX tags have tag name , attributes and children.
JSX is not a necessity to write React Applications.
JSX makes your react code simpler and elegent.
JSX ultimately transpiles to pure JavaScript which is understood by the browsers.


Props and State
===============
		Props											State
		-----											------				
1. Props get passed to the component.					State is managed within the component.
2. Function Parameters.									Variable declared in the function body.
3. Props are immutable.									State can be changed.
4. props - Functional Components						useState Hook - Functional Component
	this.props - Class Components						this.state - Class Component.
	
	
	

Hooks
=====
Built-in React Hooks
Hooks let you use different React features from your components. 
You can either use the built-in Hooks or combine them to build your own. This page lists all built-in Hooks in React.

State Hooks 
-----------
State lets a component “remember” information like user input. 
For example, a form component can use state to store the input value, while an image gallery component can use state to store the selected image index.

To add state to a component, use one of these Hooks:

useState declares a state variable that you can update directly.
useReducer declares a state variable with the update logic inside a reducer function.

function ImageGallery() {
  const [index, setIndex] = useState(0);

Context Hooks 
--------------
Context lets a component receive information from distant parents without passing it as props. For example, your app’s top-level component can pass the current UI theme to all components below, no matter how deep.

useContext reads and subscribes to a context.

function Button() {
  const theme = useContext(ThemeContext);



Ref Hooks 
----------
Refs let a component hold some information that isn’t used for rendering, like a DOM node or a timeout ID. 
Unlike with state, updating a ref does not re-render your component. Refs are an “escape hatch” from the React paradigm. 
They are useful when you need to work with non-React systems, such as the built-in browser APIs.

useRef declares a ref. You can hold any value in it, but most often it’s used to hold a DOM node.
useImperativeHandle lets you customize the ref exposed by your component. This is rarely used.
function Form() {
  const inputRef = useRef(null);

Effect Hooks 
------------
Effects let a component connect to and synchronize with external systems. 
This includes dealing with network, browser DOM, animations, widgets written using a different UI library, and other non-React code.

useEffect connects a component to an external system.
function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);
  
Effects are an “escape hatch” from the React paradigm. Don’t use Effects to orchestrate the data flow of your application. 
If you’re not interacting with an external system, you might not need an Effect.

There are two rarely used variations of useEffect with differences in timing:

useLayoutEffect fires before the browser repaints the screen. You can measure layout here.
useInsertionEffect fires before React makes changes to the DOM. Libraries can insert dynamic CSS here.


Performance Hooks 
-----------------
A common way to optimize re-rendering performance is to skip unnecessary work. 
For example, you can tell React to reuse a cached calculation or to skip a re-render if the data has not changed since the previous render.

To skip calculations and unnecessary re-rendering, use one of these Hooks:

useMemo lets you cache the result of an expensive calculation.
useCallback lets you cache a function definition before passing it down to an optimized component.
function TodoList({ todos, tab, theme }) {
  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);
  

